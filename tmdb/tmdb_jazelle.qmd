---
execute:
  warning: false
  message: false
---

### Load libraries
```{r}
library(tidyverse)
library(httr)
library(jsonlite)
```
### Run API client
```{r}
url <- "https://api.themoviedb.org/3/authentication"

personal_authorization <- paste0('Bearer ', ADD AUTH TOKEN)

response <- VERB("GET", url, add_headers('Authorization' =  personal_authorization), 
                 content_type("application/octet-stream"), accept("application/json"))

content(response, "text")
```

### Load in Kaggle dataset of Oscar nominees from 1927-2024
```{r}
oscar_nominees <- read.csv("the_oscar_award.csv")
```

### Search for a movie given title and year (to retrieve movie_id)
```{r}
# function to search movie given title and year, calls 2nd search movie (rename to search tmdb or smt) and checks if result is null, if so searches year +1, year -1
```


```{r}
# function to search for a movie by title and year
search_movie <- function(movie_title, year) {
  url <- "https://api.themoviedb.org/3/search/movie"
  
  # parameters for the query
  queryString <- list(
    query = movie_title,
    year = as.character(year)
  )
  
  response <- VERB("GET", url, query = queryString, add_headers('Authorization' = personal_authorization), content_type("application/octet-stream"), accept("application/json"))
  
  # check for response status
  if (http_error(response)) {
    stop("Failed to retrieve movie data. HTTP Status: ", status_code(response))
  }
  
  # parse json
  response_content <- content(response, "text")
  json_data <- fromJSON(response_content)
  
  # return the top movie hit
  if (length(json_data$results) > 0) {
    return(
      as.data.frame(json_data$results |>
        arrange(desc(popularity)) |> # choose based on popularity
        head(1)
    ))
  } else { # modify to search +/- 1
    return(NULL) # No results found
  }
}
```

```{r}
# test case for parasite
parasite <- search_movie("Parasite", 2020)
print(parasite)
```

```{r}
# Test case for the movie "Titanic" (1997)
titanic <- search_movie("Titanic", 1997)
print(titanic)
```

```{r}
movie_details <- apply(oscar_nominees, 1, function(row) {
  search_movie(row["film"], row["year_film"])
})

#combine all calls into one df
movie_details_df <- do.call(rbind, movie_details)

movie_details_df
```


### Search for a movie's additional details given movie_id
```{r}
fields <- c("adult", "backdrop_path", "belongs_to_collection", "budget", "genres", "homepage", "id", "imdb_id", "original_language", "original_title", "overview", "popularity", "poster_path", "production_companies", "production_countries", "release_date", "revenue", "runtime", "spoken_languages", "status", "tagline", "title", "video", "vote_average", "vote_count")
```

```{r}
parse_field <- function(json_data, field) {
  return(ifelse(!is.null(json_data[[field]]), json_data[[field]], NA))
}
```

```{r}
search_movie_extra <- function(movie_id) {
  url <- paste0("https://api.themoviedb.org/3/movie/", movie_id)
  
  # Make the GET request with the Authorization header and JSON accept header
  response <- GET(url, 
                  add_headers('Authorization' = personal_authorization),
                  content_type("application/octet-stream"), 
                  accept("application/json"))
  
  # Check for response status
  if (http_error(response)) {
    stop("Failed to retrieve movie data. HTTP Status: ", status_code(response))
  }
  
  # Parse the JSON response
  response_content <- content(response, "text")
  json_data <- fromJSON(response_content)
  
  result <- data.frame(matrix(ncol = length(fields), nrow = 1))
  colnames(result) <- fields
  
  # Safely extract all the available fields
  if (length(json_data) > 0) {
    for (field in fields) {
      result[[field]] = parse_field(json_data, field)
    }
    
    return(result) 
  } else {
    return(data.frame())
  }
}

```

```{r}
# test case for fightclub
fightclub <- search_movie_extra(550)
print(fightclub)
```

### Function to parse through movie_details_df for extra functions

```{r}
movie_data <- map_df(unique(movie_details_df$id), search_movie_extra)
```

```{r}
# look into this
length(unique(movie_details_df$id))
length(unique(oscar_nominees$film))
```

```{r}
movie_data$year = as.integer(substr(movie_data$release_date, 1, 4))
```


```{r}
# fix to join by movie AND year, need to parse year from movie data
all_data <- left_join(oscar_nominees, movie_data, by = c("film" = "title")) |>
  filter(abs(year_film - year) <= 1)
```

```{r}
sum(sapply(all_data$id, is.na))
```

```{r}
# all films nominated for 10 categories after 1939
after_1939 <- all_data |>
  filter(year_film >= 1939) |>
  filter(category != "FOREIGN LANGUAGE FILM") |>
  filter(category == "BEST PICTURE" | category == "DIRECTING" | 
         category == "ACTOR IN A LEADING ROLE" | category == "ACTRESS IN A LEADING ROLE" |
         category == "ACTOR IN A SUPPORTING ROLE" | 
         category == "ACTRESS IN A SUPPORTING ROLE" |
         category == "WRITING (Original Screenplay)" |
         category == "WRITING (Adapted Screenplay)" | category == "CINEMATOGRAPHY" |
         category == "FILM EDITING")
```


```{r}
# foreign language films nominated for top 10 categories
international <- all_data |>
  filter(year_film >= 1939) |>
  filter(map_lgl(production_countries, ~ !is.null(.))) |>
  filter(map_lgl(production_countries, ~ !("US" %in% .))) |>
  filter(category != "FOREIGN LANGUAGE FILM") |>
  filter(category == "BEST PICTURE" | category == "DIRECTING" | 
         category == "ACTOR IN A LEADING ROLE" | category == "ACTRESS IN A LEADING ROLE" |
         category == "ACTOR IN A SUPPORTING ROLE" | 
         category == "ACTRESS IN A SUPPORTING ROLE" |
         category == "WRITING (Original Screenplay)" |
         category == "WRITING (Adapted Screenplay)" | category == "CINEMATOGRAPHY" |
         category == "FILM EDITING")
```

```{r}
# domestic films nominated for top 10 categories
domestic <- all_data |>
  filter(year_film >= 1939) |>
  filter(map_lgl(production_countries, ~ !is.null(.))) |>
  filter(map_lgl(production_countries, ~ ("US" %in% .))) |>
  filter(category != "FOREIGN LANGUAGE FILM") |>
  filter(category == "BEST PICTURE" | category == "DIRECTING" | 
         category == "ACTOR IN A LEADING ROLE" | category == "ACTRESS IN A LEADING ROLE" |
         category == "ACTOR IN A SUPPORTING ROLE" | 
         category == "ACTRESS IN A SUPPORTING ROLE" |
         category == "WRITING (Original Screenplay)" |
         category == "WRITING (Adapted Screenplay)" | category == "CINEMATOGRAPHY" |
         category == "FILM EDITING")
```


````{r}
international['id'].drop_duplicates() |>
  summarize(popularity = mean(popularity), winners = mean(as.logical(winner)), 
            revenue = mean(revenue), rating = mean(vote_average), 
            num_votes = mean(vote_count))
```

````{r}
domestic |>
  filter(unique(id)) |>
  summarize(popularity = mean(popularity), winners = mean(as.logical(winner)), 
            revenue = mean(revenue), rating = mean(vote_average), 
            num_votes = mean(vote_count))
```

```{r}
after_1939 |>
  group_by(year_film, category) |>
  # compare intl films to domestic films nominated for same category in same year
  filter()
```


```{r}
ms <- all_data |>
  filter(film == "Marriage Story")
```


```{r}
international |>
  filter(year_ceremony == 2024, category == "BEST PICTURE") |>
  summarize(popularity = mean(popularity), winners = mean(as.logical(winner)), 
            budget = mean(budget), revenue = mean(revenue), rating = mean(vote_average), 
            num_votes = mean(vote_count))
```
```{r}
domestic |>
  filter(year_ceremony == 2024, category == "BEST PICTURE") |>
  summarize(popularity = mean(popularity), winners = mean(as.logical(winner)), 
          budget = mean(budget), revenue = mean(revenue), rating = mean(vote_average), 
          num_votes = mean(vote_count))
```

```{r}
all_data |>
  filter(year_ceremony == 2021, category == "BEST PICTURE")
```






### Rename film to title for consistency -- prep for joining
```{r}
library(dplyr)
oscar_nominees <- oscar_nominees |> 
  rename(title = film) # change to match movie_details_df, film -> title
```

```{r}
join_oscar <- left_join(oscar_nominees, movie_details_df, by = "title")
join_tmdb <- left_join(movie_details_df, oscar_nominees, by = "title")
# many-to-many is expected, same movie is nominated for diff categories
```

### Flattening the Data
```{r}
# Making each genre into a column
# get the list of movie genres from API
movie_list <- VERB("GET", 
                   "https://api.themoviedb.org/3/genre/movie/list", 
                   query = list(language = "en"), 
                   add_headers('Authorization' = personal_authorization),
                   content_type("application/octet-stream"), 
                   accept("application/json"))
movie_list_content <- content(movie_list, "parsed")

# make the genres list into a data frame to refer to later on
genres_list <- data.frame(
  id = sapply(movie_list_content$genres, function(x) x$id),
  name = sapply(movie_list_content$genres, function(x) x$name),
  stringsAsFactors = FALSE
)
genres_dict <- setNames(genres_list$name, genres_list$id)
```

```{r}
# figure out the most common genre_ids - ..don't really need
movie_details_df$genre_ids <- map(movie_details_df$genre_ids, ~ if (is.list(.)) unlist(.) else .)
common_genres <- movie_details_df |>
  unnest(genre_ids) |>
  select(genre_ids) |>
  group_by(genre_ids) |>
  mutate(genre_ids = genres_dict[as.character(genre_ids)]) |> 
  summarize(count_genres = n()) |>
  arrange(desc(count_genres))

# function for adding genre columns
wider_by_genre <- function(df) {
  # make sure all values are vectors
  df$genre_ids <- map(df$genre_ids, ~ if (is.list(.)) unlist(.) else .)
    
  # now, change all the number values to be genres(char)
  new_df <- df |>
    unnest(genre_ids) |> 
    distinct() |>
    mutate(genre_ids = genres_dict[as.character(genre_ids)]) |> 
    filter(!is.na(genre_ids)) |>
    mutate(valid_id = 1) |> # create binary value for the pivot_wider to use
    pivot_wider(names_from = genre_ids, values_from = valid_id, 
                values_fill = 0) # use names_prefix if want "genre_"
  
  
  return(new_df)
}

# testing the function above
wide_genre_join_tmdb <- wider_by_genre(join_tmdb)
```

```{r}
# more generic flattening of lists
flatten_lists <- function(df, feature, prefix) {
  # make sure all values in the specified column are vectors
  df[[feature]] <- map(df[[feature]], ~ if (is.list(.)) unlist(.) else .)
  
  # now, change all the number values 
  new_df <- df |> 
    unnest({{feature}}) |>  # unnest the specified column
    distinct() |> 
    filter(!is.na(.data[[feature]])) |> 
    mutate(valid_value = 1) |>  # create binary value for pivot_wider
    pivot_wider(names_from = {{feature}}, values_from = valid_value, 
                names_prefix = prefix, values_fill = 0)
  
  return(new_df)
}

# testing these two 
flatten_lists(fightclub, "production_countries", "country_")
flatten_lists(fightclub, "spoken_languages", "lang_")
flatten_lists(fightclub, "production_companies", "company_")
```

###Wrangling/Preparing for Model 
```{r}
# count # of nominations and # of wins and make data compact
all_data |>
  group_by(film) |>
  mutate(num_noms = n(),
         num_wins = sum(ifelse(winner == "True", 1, 0))) |>
  ungroup() |>
  select(-category, -name, -winner) |>
  distinct()
```

### Making CSV files
```{r, eval=FALSE}
write.csv(wider_by_genre(movie_details_df),
          "/Users/kellieau/Desktop/School/Pomona/ThirdYear/Fall2024/CompStats/groupB-spotify/tmdb/movie_details_df.csv", 
          row.names = FALSE)

#doesn't quite work, need to flatten the all_data.. 
#all_data |>
 # mutate(genre_ids = genres) |>
 # select(-genres) |>
 # wider_by_genre() |>
 # write.csv("/Users/kellieau/Desktop/School/Pomona/ThirdYear/Fall2024/CompStats/groupB-spotify/tmdb/all_data.csv", row.names = FALSE)
```

```{r, eval=FALSE}
write.csv(join_tmdb,"/Users/jazellesaligumba/Desktop/groupB-spotify/tmdb/join_tmdb.csv", row.names = FALSE)
```

```{r}
# pre-processing data frame to use for graphs
graph_data_pre75 <- all_data |>
  filter(year_ceremony >= 1975) |>
  mutate(genre_ids = genres,
         #release_month = as.integer(substr(release_date, 6, 7)
         release_day_val = as.double(paste0(substr(release_date,6,7),".", substr(release_date,9,10)))) |>
  select(-spoken_languages, -production_countries, -production_companies, 
         -belongs_to_collection, -genres) #|>
  #wider_by_genre() 
```

```{r}
# graphing the genre data (one year, all categories)
graph_data_pre75$winner <- factor(graph_data_pre75$winner, levels = c("True", "False"))

graph_data_pre75 |>
  filter(year_ceremony == 2020) |>
  unnest(genre_ids) |>
  distinct() |>
  mutate(genre_ids = genres_dict[as.character(genre_ids)]) |>
  ggplot(aes(x = genre_ids, fill = winner)) + 
  geom_bar(position = "stack") +
  theme_minimal() + 
  scale_fill_manual(values = c("False" = "#bdd7fe", "True" = "orange"),
                    alpha = c("False" = 0.5)) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
# graphing the genre data (all years, one category)
graph_data_pre75 |>
  filter(category == "BEST PICTURE") |>
  unnest(genre_ids) |>
  distinct() |>
  mutate(genre_ids = genres_dict[as.character(genre_ids)]) |>
  ggplot(aes(x = year_film, y = genre_ids, color = winner)) + 
  geom_jitter() +
  scale_color_manual(values = c("True" = "red", "False" = "#D4D4D4")) + 
  theme_minimal() 
```

```{r}
#TODO: DECIDE WHAT TYPE OF PLOT WE WANT!
# graphing the release date data (one year, all categories) 
graph_data_pre75 |>
  filter(year_ceremony == 2020) |>
  ggplot(aes(x = release_day_val, y = 0, color = winner)) +
  geom_jitter() + 
  scale_color_manual(values = c("True" = "red", "False" = "#D4D4D4")) + 
  theme_minimal()

graph_data_pre75 |>
  filter(year_ceremony == 2020) |>
  ggplot(aes(x = winner, y = release_day_val, color = winner)) +
  geom_boxplot() + 
  theme_minimal()
```

```{r}
# graphing the release date data (all years, one category)
graph_data_pre75 |>
  filter(category == "BEST PICTURE") |>
  ggplot(aes(x = year_film, y = release_day_val, color = winner)) +
  geom_point() + 
  scale_color_manual(values = c("True" = "red", "False" = "#D4D4D4")) + 
  theme_minimal()
```

```{r}
# preprocess data 
rf_data <- all_data |>
  filter(year_ceremony >= 1975) |>
  mutate(genre_ids = genres,
         release_month = as.integer(substr(release_date, 6, 7))) |>
  select(-spoken_languages, -production_countries, -production_companies, 
         -belongs_to_collection, -genres) |>
  wider_by_genre()
```


```{r}
plot_feature <- function(feature, nom) {
  data |>
    filter(category == nom, winner == "True") |>
    ggplot() +
    geom_jitter(aes(x = year, y = !!sym(feature)))
}
```

```{r}
plot_feature("budget", "BEST PICTURE")
```

```{r}
data |>
  ggplot() +
  geom_point(aes(x = year, y = (revenue / budget), color = winner))
```



```{r}
data |>
  filter(winner == "True", category == "BEST PICTURE") |>
  arrange(desc(budget))
```


### Random Forest Model




work on:
- function to filter top movie (based on popularity?) [done]
- function to query movies based on kaggle [done]
- rbind all movies with tmdb data [done]
- left join tmdb and kaggle [done]


- realized we used an api function (search) that didn't get other variables (details like revenue),
will try to change it


